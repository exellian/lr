mod parser { use lr :: { Cursor , Parser , Parse , Span } ; pub enum LexError { UnexspectedCharacter { index : usize } } pub enum Error { UnexpectedToken } # [derive (Clone)] pub enum Token < 'a > { TokenA (TokenA < 'a >) , TokenB (TokenB < 'a >) } mod token { use lr :: Peek ; pub (super) struct TokenA ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenA { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenA (_)) } } pub (super) struct TokenB ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenB { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenB (_)) } } } # [derive (Clone)] pub struct Lexer < 'a > { tokens : Vec < Token < 'a >> , position : usize , } impl < 'a > Lexer < 'a > { pub fn new (code : & 'a str) -> Result < Self , LexError > { let mut tokens = Vec :: new () ; let mut position = 0usize ; while position < code . len () { let mut best_match : Option < (usize , usize) > = None ; if code [position ..] . starts_with ("a") { let len = "a" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 0)) , } } if code [position ..] . starts_with ("b") { let len = "b" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 1)) , } } match best_match { Some ((len , idx)) => { if len == 0 { return Err (LexError :: UnexspectedCharacter { index : position }) ; } let end = position + len ; let span = Span :: new (code , position .. end) ; let token = match idx { 0 => Token :: TokenA (TokenA { span }) , 1 => Token :: TokenB (TokenB { span }) , _ => unreachable ! () , } ; tokens . push (token) ; position = end ; } None => { return Err (LexError :: UnexspectedCharacter { index : position }) ; } } } Ok (Self { tokens , position : 0 }) } } impl < 'a > Cursor for Lexer < 'a > { type Item = Token < 'a > ; fn next (& mut self) -> Option < Self :: Item > { if self . position < self . tokens . len () { let token = self . tokens [self . position] . clone () ; self . position += 1 ; Some (token) } else { None } } fn peek (& mut self , k : usize) -> Option < & Self :: Item > { self . tokens . get (self . position + k) } fn position (& self) -> usize { self . position } } pub struct TokenA < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenA < 'a > { fn clone (& self) -> Self { TokenA { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenA < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenA (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenB < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenB < 'a > { fn clone (& self) -> Self { TokenB { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenB < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenB (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct ChildTail < 'a > { left : Box < Child < 'a >> , right : ChildTailRight < 'a > } impl < 'a > Parse for ChildTail < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , left) = parser . parse :: < Child > () ? ; let (parser , right) = parser . parse :: < ChildTailRight > () ? ; Ok ((parser , ChildTail { left : Box :: new (left) , right })) } } pub struct ChildTailRight < 'a > { arg_0 : TokenA < 'a > } impl < 'a > Parse for ChildTailRight < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse_token :: < TokenA > () ? ; Ok ((parser , ChildTailRight { arg_0 })) } } pub struct StartTail < 'a > { left : Box < Start < 'a >> , right : StartTailRight < 'a > } impl < 'a > Parse for StartTail < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , left) = parser . parse :: < Start > () ? ; let (parser , right) = parser . parse :: < StartTailRight > () ? ; Ok ((parser , StartTail { left : Box :: new (left) , right })) } } pub struct StartTailRight < 'a > { arg_0 : Child < 'a > } impl < 'a > Parse for StartTailRight < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < Child > () ? ; Ok ((parser , StartTailRight { arg_0 })) } } pub enum Child < 'a > { ChildTail (ChildTail < 'a >) , TokenA (TokenA < 'a >) } impl < 'a > Parse for Child < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (mut parser , mut this) = let (parser , res) = parser . parse_token :: < TokenA > () ? ; (parser , Child :: TokenA (res)) ; let (parser , this) = loop { let (parser1 , res) = let (parser , right) = parser . opt_parse :: < ChildTailRight > () ; (parser , match right { None => Err (this) , Some (right) => { Ok (Child :: ChildTail (ChildTail { left : Box :: new (this) , right })) } }) ; match res { Ok (new) => { this = new ; parser = parser1 ; } Err (old) => { break (parser1 , old) } } } ; Ok ((parser , this)) } } pub enum Start < 'a > { StartTail (StartTail < 'a >) , TokenB (TokenB < 'a >) } impl < 'a > Parse for Start < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (mut parser , mut this) = let (parser , res) = parser . parse_token :: < TokenB > () ? ; (parser , Start :: TokenB (res)) ; let (parser , this) = loop { let (parser1 , res) = let (parser , right) = parser . opt_parse :: < StartTailRight > () ; (parser , match right { None => Err (this) , Some (right) => { Ok (Start :: StartTail (StartTail { left : Box :: new (this) , right })) } }) ; match res { Ok (new) => { this = new ; parser = parser1 ; } Err (old) => { break (parser1 , old) } } } ; Ok ((parser , this)) } } }