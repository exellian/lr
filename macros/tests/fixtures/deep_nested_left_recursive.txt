mod parser { use lr :: { Cursor , Parser , Parse , Span } ; use std :: marker :: PhantomData ; pub enum LexError { UnexspectedCharacter } pub enum Error { UnexpectedToken } pub enum Token < 'a > { TokenA (TokenA < 'a >) , TokenB (TokenB < 'a >) , TokenC (TokenC < 'a >) , TokenD (TokenD < 'a >) , TokenE (TokenE < 'a >) , TokenZ (TokenZ < 'a >) } mod token { use lr :: Peek ; pub (super) struct TokenA ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenA { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenA (_)) } } pub (super) struct TokenB ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenB { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenB (_)) } } pub (super) struct TokenC ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenC { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenC (_)) } } pub (super) struct TokenD ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenD { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenD (_)) } } pub (super) struct TokenE ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenE { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenE (_)) } } pub (super) struct TokenZ ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenZ { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenZ (_)) } } } # [derive (Clone)] pub struct Lexer < 'a > { _a : PhantomData < & 'a () > } impl < 'a > Cursor for Lexer < 'a > { type Item = Token < 'a > ; fn next (& mut self) -> Option < Self :: Item > { todo ! () } fn peek (& mut self , k : usize) -> Option < & Self :: Item > { todo ! () } fn position (& self) -> usize { todo ! () } } pub struct TokenA < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenA < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenA (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenB < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenB < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenB (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenC < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenC < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenC (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenD < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenD < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenD (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenE < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenE < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenE (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenZ < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenZ < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenZ (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct SeqA < 'a > { arg_0 : Box < EnumA < 'a >> , arg_1 : TokenA < 'a > } impl < 'a > Parse for SeqA < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < EnumA > () ? ; let (parser , arg_1) = parser . parse_token :: < TokenA > () ? ; Ok ((parser , SeqA { arg_0 : Box :: new (arg_0) , arg_1 })) } } pub struct SeqB < 'a > { arg_0 : Box < EnumB < 'a >> , arg_1 : TokenC < 'a > } impl < 'a > Parse for SeqB < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < EnumB > () ? ; let (parser , arg_1) = parser . parse_token :: < TokenC > () ? ; Ok ((parser , SeqB { arg_0 : Box :: new (arg_0) , arg_1 })) } } pub struct SeqC < 'a > { arg_0 : Box < Start < 'a >> , arg_1 : TokenD < 'a > } impl < 'a > Parse for SeqC < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < Start > () ? ; let (parser , arg_1) = parser . parse_token :: < TokenD > () ? ; Ok ((parser , SeqC { arg_0 : Box :: new (arg_0) , arg_1 })) } } pub struct StartTail < 'a > { arg_0 : Box < SeqA < 'a >> } impl < 'a > Parse for StartTail < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < SeqA > () ? ; Ok ((parser , StartTail { arg_0 : Box :: new (arg_0) })) } } pub enum EnumA < 'a > { SeqB (SeqB < 'a >) , TokenB (TokenB < 'a >) } impl < 'a > Parse for EnumA < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , this) = if parser . peek (token :: TokenB , 0usize) { let (parser , res) = parser . parse_token :: < TokenB > () ? ; (parser , EnumA :: TokenB (res)) } else { let (parser , res) = parser . parse :: < SeqB > () ? ; (parser , EnumA :: SeqB (res)) } ; Ok ((parser , this)) } } pub enum EnumB < 'a > { SeqC (SeqC < 'a >) , TokenE (TokenE < 'a >) } impl < 'a > Parse for EnumB < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , this) = if parser . peek (token :: TokenE , 0usize) { let (parser , res) = parser . parse_token :: < TokenE > () ? ; (parser , EnumB :: TokenE (res)) } else { let (parser , res) = parser . parse :: < SeqC > () ? ; (parser , EnumB :: SeqC (res)) } ; Ok ((parser , this)) } } pub enum Start < 'a > { StartTail (StartTail < 'a >) , TokenZ (TokenZ < 'a >) } impl < 'a > Parse for Start < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , this) = if parser . peek (token :: TokenB , 0usize) { let (parser , res) = parser . parse :: < StartTail > () ? ; (parser , Start :: StartTail (res)) } else { let (parser , res) = parser . parse_token :: < TokenZ > () ? ; (parser , Start :: TokenZ (res)) } ; Ok ((parser , this)) } } }