mod parser { use lr :: { Cursor , Parser , Parse , Span } ; pub enum LexError { UnexspectedCharacter { index : usize } } pub enum Error { UnexpectedToken } # [derive (Clone)] pub enum Token < 'a > { TokenA (TokenA < 'a >) , TokenB (TokenB < 'a >) , TokenC (TokenC < 'a >) , TokenD (TokenD < 'a >) , TokenE (TokenE < 'a >) , TokenZ (TokenZ < 'a >) } mod token { use lr :: Peek ; pub (super) struct TokenA ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenA { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenA (_)) } } pub (super) struct TokenB ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenB { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenB (_)) } } pub (super) struct TokenC ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenC { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenC (_)) } } pub (super) struct TokenD ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenD { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenD (_)) } } pub (super) struct TokenE ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenE { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenE (_)) } } pub (super) struct TokenZ ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenZ { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenZ (_)) } } } # [derive (Clone)] pub struct Lexer < 'a > { tokens : Vec < Token < 'a >> , position : usize , } impl < 'a > Lexer < 'a > { pub fn new (code : & 'a str) -> Result < Self , LexError > { let mut tokens = Vec :: new () ; let mut position = 0usize ; while position < code . len () { let mut best_match : Option < (usize , usize) > = None ; if code [position ..] . starts_with ("a") { let len = "a" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 0)) , } } if code [position ..] . starts_with ("b") { let len = "b" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 1)) , } } if code [position ..] . starts_with ("c") { let len = "c" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 2)) , } } if code [position ..] . starts_with ("d") { let len = "d" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 3)) , } } if code [position ..] . starts_with ("e") { let len = "e" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 4)) , } } if code [position ..] . starts_with ("z") { let len = "z" . len () ; match best_match { Some ((best_len , _)) if best_len >= len => { } _ => best_match = Some ((len , 5)) , } } match best_match { Some ((len , idx)) => { if len == 0 { return Err (LexError :: UnexspectedCharacter { index : position }) ; } let end = position + len ; let span = Span :: new (code , position .. end) ; let token = match idx { 0 => Token :: TokenA (TokenA { span }) , 1 => Token :: TokenB (TokenB { span }) , 2 => Token :: TokenC (TokenC { span }) , 3 => Token :: TokenD (TokenD { span }) , 4 => Token :: TokenE (TokenE { span }) , 5 => Token :: TokenZ (TokenZ { span }) , _ => unreachable ! () , } ; tokens . push (token) ; position = end ; } None => { return Err (LexError :: UnexspectedCharacter { index : position }) ; } } } Ok (Self { tokens , position : 0 }) } } impl < 'a > Cursor for Lexer < 'a > { type Item = Token < 'a > ; fn next (& mut self) -> Option < Self :: Item > { if self . position < self . tokens . len () { let token = self . tokens [self . position] . clone () ; self . position += 1 ; Some (token) } else { None } } fn peek (& mut self , k : usize) -> Option < & Self :: Item > { self . tokens . get (self . position + k) } fn position (& self) -> usize { self . position } } pub struct TokenA < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenA < 'a > { fn clone (& self) -> Self { TokenA { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenA < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenA (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenB < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenB < 'a > { fn clone (& self) -> Self { TokenB { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenB < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenB (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenC < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenC < 'a > { fn clone (& self) -> Self { TokenC { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenC < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenC (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenD < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenD < 'a > { fn clone (& self) -> Self { TokenD { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenD < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenD (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenE < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenE < 'a > { fn clone (& self) -> Self { TokenE { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenE < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenE (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenZ < 'a > { span : Span < 'a > } impl < 'a > Clone for TokenZ < 'a > { fn clone (& self) -> Self { TokenZ { span : Span :: new (self . span . code , self . span . range . clone ()) } } } impl < 'a > Parse for TokenZ < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenZ (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct SeqA < 'a > { arg_0 : Box < EnumA < 'a >> , arg_1 : TokenA < 'a > } impl < 'a > Parse for SeqA < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < EnumA > () ? ; let (parser , arg_1) = parser . parse_token :: < TokenA > () ? ; Ok ((parser , SeqA { arg_0 : Box :: new (arg_0) , arg_1 })) } } pub struct SeqB < 'a > { arg_0 : Box < EnumB < 'a >> , arg_1 : TokenC < 'a > } impl < 'a > Parse for SeqB < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < EnumB > () ? ; let (parser , arg_1) = parser . parse_token :: < TokenC > () ? ; Ok ((parser , SeqB { arg_0 : Box :: new (arg_0) , arg_1 })) } } pub struct SeqC < 'a > { arg_0 : Box < Start < 'a >> , arg_1 : TokenD < 'a > } impl < 'a > Parse for SeqC < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < Start > () ? ; let (parser , arg_1) = parser . parse_token :: < TokenD > () ? ; Ok ((parser , SeqC { arg_0 : Box :: new (arg_0) , arg_1 })) } } pub struct StartTail < 'a > { arg_0 : Box < SeqA < 'a >> } impl < 'a > Parse for StartTail < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse :: < SeqA > () ? ; Ok ((parser , StartTail { arg_0 : Box :: new (arg_0) })) } } pub enum EnumA < 'a > { SeqB (SeqB < 'a >) , TokenB (TokenB < 'a >) } impl < 'a > Parse for EnumA < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , this) = if parser . peek (token :: TokenB , 0usize) { let (parser , res) = parser . parse_token :: < TokenB > () ? ; (parser , EnumA :: TokenB (res)) } else { let (parser , res) = parser . parse :: < SeqB > () ? ; (parser , EnumA :: SeqB (res)) } ; Ok ((parser , this)) } } pub enum EnumB < 'a > { SeqC (SeqC < 'a >) , TokenE (TokenE < 'a >) } impl < 'a > Parse for EnumB < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , this) = if parser . peek (token :: TokenE , 0usize) { let (parser , res) = parser . parse_token :: < TokenE > () ? ; (parser , EnumB :: TokenE (res)) } else { let (parser , res) = parser . parse :: < SeqC > () ? ; (parser , EnumB :: SeqC (res)) } ; Ok ((parser , this)) } } pub enum Start < 'a > { StartTail (StartTail < 'a >) , TokenZ (TokenZ < 'a >) } impl < 'a > Parse for Start < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , this) = if parser . peek (token :: TokenB , 0usize) { let (parser , res) = parser . parse :: < StartTail > () ? ; (parser , Start :: StartTail (res)) } else { let (parser , res) = parser . parse_token :: < TokenZ > () ? ; (parser , Start :: TokenZ (res)) } ; Ok ((parser , this)) } } }