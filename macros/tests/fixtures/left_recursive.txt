mod parser { use lr :: { Cursor , Parser , Parse , Span } ; use std :: marker :: PhantomData ; pub enum LexError { UnexspectedCharacter } pub enum Error { UnexpectedToken } pub enum Token < 'a > { TokenA (TokenA < 'a >) , TokenB (TokenB < 'a >) } mod token { use lr :: Peek ; pub (super) struct TokenA ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenA { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenA (_)) } } pub (super) struct TokenB ; impl < 'a > Peek < super :: Lexer < 'a >> for TokenB { fn peek (token : & super :: Token < 'a >) -> bool { matches ! (token , super :: Token :: TokenB (_)) } } } # [derive (Clone)] pub struct Lexer < 'a > { _a : PhantomData < & 'a () > } impl < 'a > Cursor for Lexer < 'a > { type Item = Token < 'a > ; fn next (& mut self) -> Option < Self :: Item > { todo ! () } fn peek (& mut self , k : usize) -> Option < & Self :: Item > { todo ! () } fn position (& self) -> usize { todo ! () } } pub struct TokenA < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenA < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenA (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct TokenB < 'a > { span : Span < 'a > } impl < 'a > Parse for TokenB < 'a > { type Error = Error ; type Parser = Lexer < 'a > ; fn parse (mut cursor : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { if let Some (Token :: TokenB (token)) = cursor . next () { Ok ((cursor , token)) } else { Err (Error :: UnexpectedToken) } } } pub struct StartTail < 'a > { left : Box < Start < 'a >> , right : StartTailRight < 'a > } impl < 'a > Parse for StartTail < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , left) = parser . parse :: < Start > () ? ; let (parser , right) = parser . parse :: < StartTailRight > () ? ; Ok ((parser , StartTail { left : Box :: new (left) , right })) } } pub struct StartTailRight < 'a > { arg_0 : TokenA < 'a > } impl < 'a > Parse for StartTailRight < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (parser , arg_0) = parser . parse_token :: < TokenA > () ? ; Ok ((parser , StartTailRight { arg_0 })) } } pub enum Start < 'a > { StartTail (StartTail < 'a >) , TokenB (TokenB < 'a >) } impl < 'a > Parse for Start < 'a > { type Error = Error ; type Parser = Parser < Lexer < 'a >> ; fn parse (mut parser : Self :: Parser) -> Result < (Self :: Parser , Self) , Self :: Error > { let (mut parser , mut this) = let (parser , res) = parser . parse_token :: < TokenB > () ? ; (parser , Start :: TokenB (res)) ; let (parser , this) = loop { let (parser1 , res) = let (parser , right) = parser . opt_parse :: < StartTailRight > () ; (parser , match right { None => Err (this) , Some (right) => { Ok (Start :: StartTail (StartTail { left : Box :: new (this) , right })) } }) ; match res { Ok (new) => { this = new ; parser = parser1 ; } Err (old) => { break (parser1 , old) } } } ; Ok ((parser , this)) } } }